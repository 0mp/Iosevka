###### COMMON SHAPES

define [Ring u d l r transformShiftOnly] : begin
	local my ((u + d) / 2)
	local mx ((l + r) / 2)
	local s : new Stroke
	if [not transformShiftOnly] : s.set-transform globalTransform
	s.start-from mx d
		:.cubic-to (mx + (l - mx) * CKAPPA) d l (my + (d - my) * CKAPPA) l my
		:.cubic-to l (my + (u - my) * CKAPPA) (mx + (l - mx) * CKAPPA) u mx u
		:.cubic-to (mx + (r - mx) * CKAPPA) u r (my + (u - my) * CKAPPA) r my
		:.cubic-to r (my + (d - my) * CKAPPA) (mx + (r - mx) * CKAPPA) d mx d
	if transformShiftOnly : begin
		local {.x mx1 .y my1} [tp globalTransform {.x mx .y my}]
		foreach p [items-of s.points] : begin
			set p.x : p.x + mx1 - mx
			set p.y : p.y + my1 - my
	return s.points

define [RingAt x y r] : Ring (y + r) (y - r) (x - r) (x + r)
define [DotAt x y r] : Ring (y + r) (y - r) (x - r) (x + r) true
define [ORing u d l r sma smb shift] : begin
	local mx ((l + r) / 2)
	local s : new Stroke
		:.set-transform globalTransform
		:.start-from (mx + shift) d
		:.arc-hv-to  l (d + smb)
		:.line-to    l (u - sma)
		:.arc-vh-to  (mx - shift) u
		:.arc-hv-to  r (u - smb)
		:.line-to    r (d + sma)
		:.arc-vh-to  (mx + shift) d
	return s.points

define [leftwardTopSerif x y length] : begin
	return : new Stroke
		:.set-transform globalTransform
		:.start-from (x + HALFSTROKE * CORRECTION_HX) y
		:.heads-to LEFTWARD
		:.set-width STROKE 0
		:.line-to (x - length - globalTransform.yx * STROKE) y
		:.to-outline

define [leftwardBottomSerif x y length] : begin
	return : new Stroke
		:.set-transform globalTransform
		:.start-from (x + HALFSTROKE * CORRECTION_HX) y
		:.heads-to LEFTWARD
		:.set-width 0 STROKE
		:.line-to (x - length + globalTransform.yx * STROKE) y
		:.to-outline

define [rightwardTopSerif x y length] : begin
	return : new Stroke
		:.set-transform globalTransform
		:.start-from (x - HALFSTROKE * CORRECTION_HX) y
		:.heads-to RIGHTWARD
		:.set-width 0 STROKE
		:.line-to (x + length - globalTransform.yx * STROKE) y
		:.to-outline

define [rightwardBottomSerif x y length] : begin
	return : new Stroke
		:.set-transform globalTransform
		:.start-from (x - HALFSTROKE * CORRECTION_HX) y
		:.heads-to RIGHTWARD
		:.set-width STROKE 0
		:.line-to (x + length + globalTransform.yx * STROKE) y
		:.to-outline

define [centerTopSerif x y length] : begin
	return : new Stroke
		:.set-transform globalTransform
		:.start-from (x + length - globalTransform.yx * STROKE) y
		:.set-width STROKE 0
		:.line-to (x - length - globalTransform.yx * STROKE) y
		:.to-outline

define [centerBottomSerif x y length] : begin
	return : new Stroke
		:.set-transform globalTransform
		:.start-from (x + length + globalTransform.yx * STROKE) y
		:.set-width 0 STROKE
		:.line-to (x - length + globalTransform.yx * STROKE) y
		:.to-outline


define [xsStrand _xleft yleft _xright yright _halfstroke0 _halfstroke1 _ess _expansion _roundp] : begin
	local expansion : _expansion || 0.25
	local halfstroke0 : _halfstroke0 || HALFSTROKE
	local halfstroke1 : _halfstroke1 || HALFSTROKE
	local ess         : _ess || (halfstroke0 + halfstroke1) / 2
	local upright : Upright
	# calculate italic correction
	local outline : [new Stroke
			:.set-transform globalTransform
			:.start-from _xleft yleft
			:.set-width  (2 * halfstroke0) 0
			:.line-to    _xleft (yleft - 1000)
			:.max-samples 1
			:.to-outline].0.map : [p] -> [tp upright p]
	local xItalicCorrection : -(outline.3.x - outline.0.x) / (2 * halfstroke0)
	local yItalicCorrection : (outline.3.y - outline.0.y) / (2 * halfstroke0)

	local roundsize : (_roundp || SMOOTHA * 0.4) * [if (yleft < yright) (-1) 1]
	local roundleft   (yleft - roundsize)
	local roundright  (yright + roundsize)
	local xleft     : _xleft + halfstroke0 * xItalicCorrection
	local xright    : _xright - halfstroke1 * xItalicCorrection
	local sxleft    : mix xleft xright (0.5 - expansion)
	local sxright   : mix xleft xright (0.5 + expansion)
	local syleft    : mix roundleft roundright (0.5 - expansion)
	local syright   : mix roundleft roundright (0.5 + expansion)
	
	return : new Stroke
		:.set-transform globalTransform
		:.start-from xleft (yleft - halfstroke0 * yItalicCorrection)
		:.set-width  halfstroke0 halfstroke0
		:.curve-to   xleft roundleft sxleft syleft
		:.set-width  ess ess
		:.line-to    sxright syright
		:.curve-to   xright roundright xright (yright + halfstroke1 * yItalicCorrection)
		:.set-width  halfstroke1 halfstroke1
		:.to-outline

define [sStrand yleft yright _expansion] : begin
	return : xsStrand SB yleft RIGHTSB yright HALFSTROKE HALFSTROKE HALFSTROKE _expansion (SMOOTHA * 0.4)


define [halfXStrand _leftx lefty rightx righty turn straight tension _fine] : glyph-construction
	local leftx : _leftx + (HALFSTROKE * CORRECTION_HX * [if (rightx > _leftx) 1 (-1)])
	local fine  : (_fine || STROKE) * 0.5
	
	local turnyleft : mix lefty righty turn
	local cyleft : mix turnyleft righty tension
	
	local straightxleft : mix leftx rightx straight
	local straightyleft : mix cyleft righty straight
	
	include : spiro
		widths.center
		flat leftx lefty [heading [if (lefty < righty) UPWARD DOWNWARD]]
		curl leftx turnyleft [heading [if (lefty < righty) UPWARD DOWNWARD]]
		quadcontrols 0 ((cyleft - turnyleft) / (straightyleft - turnyleft)) 4 unimportant
		flat straightxleft straightyleft
		curl rightx righty


define [xStrand _leftx lefty _rightx righty turn straight tension] : glyph-construction
	local middlex : mix _leftx _rightx 0.5
	local middley : mix lefty righty 0.5
	
	include : halfXStrand _leftx lefty middlex middley turn straight tension
	include : halfXStrand _rightx righty middlex middley turn straight tension

define [nShoulderKnots left right fine _top _bottom _sma _smb _wide] : begin
	local top : fallback _top XH
	local bottom : fallback _bottom 0
	local sma : fallback _sma SMALLSMOOTHA
	local smb : fallback _smb SMALLSMOOTHB
	local stroke : fallback _wide STROKE
	local slope : shoulderMidSlope fine
	local middle : [mix (left - stroke * CORRECTION_HX) right 0.5] + (slope - CORRECTION_OMIDX) * stroke
	return : list
		flat left (top - sma - 2) [widths fine 0]
		curl left (top - sma)
		arcvh
		g4   middle (top - O) [widths.heading 0 stroke {.y (1) .x (slope)}]
		archv
		flat right (top - smb)
		curl right bottom [heading DOWNWARD]

define [nShoulder left right fine _top _bottom _sma _smb _wide] : let [a arguments] : glyph-construction
	include : spiro : nShoulderKnots.apply null a


define [mShoulderSpiro left right top bottom width fine] : glyph-construction
	local fix : CORRECTION_VS * CORRECTION_HX * width / STROKE
	local sm : SMALLSMOOTH * 0.75
	include : spiro-outline
		corner (right - width * CORRECTION_HX) bottom
		curl   (right - width * CORRECTION_HX) (top - sm + fix)
		arcvh 8 'no-tiny'
		g2     [mix left (right - width * CORRECTION_HX) 0.5] (top - O - width)
		archv 8 'no-tiny'
		flat   left (top - sm - fix)
		corner left (top - sm - fix - 1)
		corner (left - fine) (top - sm - 1)
		curl   (left - fine) (top - sm)
		arcvh 8 'no-tiny'
		g2     [mix (left - fine * CORRECTION_HX) right 0.5] (top - O)
		archv 8 'no-tiny'
		flat   right (top - sm)
		corner right bottom
		close

define [smallo u d l r _width _sma _smb ai] : glyph-construction
	local middle : (l + r) / 2
	local width : fallback _width STROKE
	local sma : fallback _sma SMALLSMOOTHA
	local smb : fallback _smb SMALLSMOOTHB
	local mc : CORRECTION_OMIDX * width
	if (u - d > sma + smb) : then : begin
		include : spiro
			widths width 0
			g4 (middle - mc) (u - O)
			archv
			[if ai flat.ai flat] (l + O) (u - sma)
			[if ai curl.ai curl] (l + O) (d + smb)
			arcvh
			g4 (middle + mc) (d + O)
			archv
			[if ai flat.ai flat] (r - O) (d + sma)
			[if ai curl.ai curl] (r - O) (u - smb)
			arcvh
			close
	: else : begin
		local ymiddlea : mix d u (smb / (sma + smb))
		local ymiddleb : mix d u (sma / (sma + smb))
		include : spiro
			widths width 0
			g4 (middle - mc) (u - O)
			archv
			g4 (l + O) ymiddlea
			arcvh
			g4 (middle + mc) (d + O)
			archv
			g4 (r - O) ymiddleb
			arcvh
			close


define [HBar xleft xright y _fine] : glyph-construction
	local fine : [fallback _fine STROKE] / 2
	include : create-stroke
		:.set-transform globalTransform
		:.start-from xleft y
		:.heads-to RIGHTWARD
		:.set-width fine fine
		:.line-to xright y
		:.heads-to RIGHTWARD

define [HBarTop xl xr y _fine] : HBar xl xr (y - [fallback _fine STROKE] * 0.5) _fine
define [HBarBottom xl xr y _fine] : HBar xl xr (y + [fallback _fine STROKE] * 0.5) _fine
define [HOverlayBar xleft xright y] : HBar xleft xright y OVERLAYSTROKE
define [VBar x ydown yup _fine] : glyph-construction
	local fine : fallback _fine STROKE
	include : spiro
		widths.center fine
		flat x ydown [heading [if (ydown < yup) UPWARD DOWNWARD]]
		curl x yup [heading [if (ydown < yup) UPWARD DOWNWARD]]

define [VBarLeft x yd yu _fine] : VBar (x + [fallback _fine STROKE] * 0.5 * CORRECTION_HX) yd yu _fine
define [VBarRight x yd yu _fine] : VBar (x - [fallback _fine STROKE] * 0.5 * CORRECTION_HX) yd yu _fine

define [VerticalHook x y extend depth fine] : glyph-construction
	include : spiro
		widths.center [fallback fine STROKE]
		flat x y [heading [if (depth > 0) DOWNWARD UPWARD]]
		curl x (y - [if (depth > 0) 0.01 (-0.01)]) [heading [if (depth > 0) DOWNWARD UPWARD]]
		flat (x + extend - [if (extend > 0) 0.01 (-0.01)]) (y - depth)
		curl (x + extend) (y - depth)

define [LegShape xt xb xs top bottom _fine] : glyph-construction
	local fine : fallback _fine STROKE
	include : spiro
		widths.lhs fine
		flat xt top [heading DOWNWARD]
		curl xb (bottom + LONGJUT)
		alsothruthem {{0.5 0.94}} important
		flat (xs + 1) (bottom + fine) [heading LEFTWARD]
		curl xs (bottom + fine) [heading LEFTWARD]

define [LeftHook x y xextend] : glyph-construction
	local fine : adviceBlackness 4.25
	include : spiro
		widths.lhs fine
		flat [fallback xextend : x + 1] y
		curl x y
		archv
		g4 (x - fine * 1.5) (y - HOOKX)


# Common transformations
define [FlipAround x y sx sy] : glyph-construction
	apply-transform : Upright
	apply-transform : Translate (-x) (-y)
	apply-transform : Scale [fallback sx (-1)] [fallback sy sx (-1)]
	apply-transform : Translate x y
	apply-transform : Italify

# Spiro shapes
define [determineMixR w v] : piecewise
	(w <= v)   0.5
	true     : 1 / ([Math.pow (1 - [Math.pow (1 - v / w) SUPERNESS]) (1 / SUPERNESS)] + 1)
define nHookSegments 4

define [HookShape toStraight toFinish isStart y tight s] : begin
	local atBottom : toStraight.y > y
	local ltr : if isStart (toFinish.x < toStraight.x) (toFinish.x > toStraight.x)
	toFinish.x = toFinish.x + OXHOOK * [if ltr (-1) 1] * [if isStart (-1) 1]
	if (atBottom && ltr && !isStart) : begin
		toFinish.x = toFinish.x + TAILADJX * globalTransform.yx
		toFinish.y = toFinish.y - TAILADJY * globalTransform.yx

	local w : Math.abs (toStraight.y - y)
	local v : Math.abs (toFinish.y - y)
	local u : Math.abs (toFinish.x - toStraight.x)
	local mixr : determineMixR w v
	local mx ([mix toStraight.x toFinish.x mixr] + ([if tight 0 : if atBottom 1 (-1)] * CORRECTION_OMIDX) * [fallback s STROKE])
	local keyKnot : g4.[if ltr "right" "left"].mid mx y [if tight [heading [if ltr RIGHTWARD LEFTWARD]] nothing]
	
	local segBefore {}
	local segAfter {}
	foreach [j : range 1 nHookSegments] : begin
		local fraction : j / nHookSegments
		local fractionAfter : fraction * (1 - mixr) / mixr
		local myfinal : superxy ((1 - mixr) / mixr)
		segBefore.push : g4 [mix mx toStraight.x fraction] [mix y toStraight.y (1 - [superxy fraction])] unimportant
		segAfter.push : g4 [mix mx toFinish.x fraction] [mix y toFinish.y ((1 - [superxy fractionAfter]) / (1 - myfinal))] unimportant
		if (!tight && w < u * mixr) : set segAfter {}
	if isStart
	: then : return : list
		segAfter.reverse
		* keyKnot
		* segBefore
	: else : return : list
		segBefore.reverse
		* keyKnot
		* segAfter

define [hookstart y tight s] : return {.type 'interpolate' .af [lambda [before after] [HookShape after before true y tight s]]}
define [hookend y tight s] : return {.type 'interpolate' .af [lambda [before after] [HookShape before after false y tight s]]}

define [WaveShape l r cy extendy tension sw] : glyph-construction
	local cx : mix l r 0.5
	local wavex : (r - l) * tension
	local endwavey : extendy * 0.95
	include : spiro
		widths.center sw
		g4 l (cy - endwavey)
		bezcontrols.absolute (l + wavex) (cy + extendy) (cx - wavex) (cy + extendy) 6 important
		g4 cx cy
		bezcontrols.absolute (cx + wavex) (cy - extendy) (r - wavex) (cy - extendy) 6 important
		g4 r (cy + endwavey)

# Derived subfonts
define [Fork glyphs params] : begin
	local p : Object.create params
	local shouldBuildList {}
	foreach glyphid [items-of glyphs] : set shouldBuildList : shouldBuildList.concat {glyphid :: dependencyProfile.(glyphid)}
	local forkFont : buildFont p shouldBuildList
	return forkFont.glyfMap

define [Miniature glyphs fold scale] : begin
	local forkedPara : Object.create para
	forkedPara.stroke = [adviceBlackness fold] / scale
	forkedPara.ess = para.ess * forkedPara.stroke / para.stroke
	forkedPara.sb = SB / 2
	return : Fork glyphs forkedPara

define [Thinner glyphs p] : begin
	local forkedPara : Object.create para
	forkedPara.width = WIDTH * p
	return : Fork glyphs forkedPara

define [Widen glyphs p psb] : begin
	local forkedPara : Object.create para
	forkedPara.width = WIDTH * p
	forkedPara.sb = SB * [fallback psb p]
	forkedPara.accentx = ACCENTX * p
	forkedPara.jut = JUT * p
	forkedPara.longjut = LONGJUT * p
	forkedPara.hookx = HOOKX * p
	#forkedPara.smoothadjust = para.smoothadjust / p
	return : Fork glyphs forkedPara

define [turned newid unicode id x y mark] : create-glyph [fallback newid : 'turn' + id] : glyph-construction
	if unicode : assign-unicode unicode
	include glyphs.(id) [if mark false AS_BASE]
	if mark : include mark
	include : FlipAround x y

# Dual derivatives
define [dual newid unicode id spacing] : create-glyph [fallback newid : 'double' + id] : glyph-construction
	if unicode : assign-unicode unicode
	include glyphs.(id) AS_BASE
	apply-transform : Translate (-spacing) 0
	include glyphs.(id)
	apply-transform : Translate (spacing / 2) 0

define [vdual newid unicode id spacing] : create-glyph [fallback newid : 'double' + id] : glyph-construction
	if unicode : assign-unicode unicode
	include : create-glyph : glyph-construction
		include glyphs.(id)
		apply-transform : Upright
	apply-transform : Translate 0 (-spacing)
	include : create-glyph : glyph-construction
		include glyphs.(id)
		apply-transform : Upright
	apply-transform : Translate 0 (spacing / 2)
	apply-transform : Italify

# Full-width derivatives
define [fwl newid unicode id] : create-glyph [fallback newid : 'fwl' + id] : glyph-construction
	if unicode : assign-unicode unicode
	include glyphs.(id)
	set-width FULLWIDTH

define [fwr newid unicode id] : create-glyph [fallback newid : 'fwr' + id] : glyph-construction
	if unicode : assign-unicode unicode
	include glyphs.(id)
	set-width FULLWIDTH
	apply-transform : Translate (FULLWIDTH - WIDTH) 0

define [dwl newid unicode id] : create-glyph [fallback newid : 'dwl' + id] : glyph-construction
	if unicode : assign-unicode unicode
	include glyphs.(id)
	set-width UPM

define [dwr newid unicode id] : create-glyph [fallback newid : 'dwr' + id] : glyph-construction
	if unicode : assign-unicode unicode
	include glyphs.(id)
	set-width UPM
	apply-transform : Translate (UPM - WIDTH) 0

define [dwc newid unicode id] : create-glyph [fallback newid : 'dwc' + id] : glyph-construction
	if unicode : assign-unicode unicode
	include glyphs.(id)
	set-width UPM
	apply-transform : Translate ((UPM - WIDTH) / 2) 0
