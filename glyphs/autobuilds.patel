### Automatic builds

# Build miniature clyphs : circled, superscripts, subscripts...
define [Miniature glyphs fold scale] : begin {
	local forkedPara : Object.create para
	forkedPara.upmscale = 1
	forkedPara.stroke = [adviceBlackness fold] / scale
	forkedPara.sb = SB / 2
	local shouldBuildList ()
	foreach glyphid [items-of glyphs] : set shouldBuildList : shouldBuildList.concat (glyphid :: dependencyProfile.(glyphid))
	local forkFont : buildFont forkedPara shouldBuildList
	return forkFont.glyfMap
}
define [createCircledGlyphs records] : if [not recursive] : begin {
	local pendingGlyphs : records.map : [record] -> record.1
	local miniatureFont : Miniature pendingGlyphs 3.7 0.7
	
	foreach (unicode glyphid) [items-of records] : create-glyph ['circled_' + glyphid] : glyph-construction {
		local sw [adviceBlackness 6]
		if unicode : assign-unicode unicode
		include : create-glyph : glyph-construction {
			include miniatureFont.(glyphid)
			apply-transform : Upright
			apply-transform : Scale 0.45
			apply-transform : Translate [[WIDTH - WIDTH * 0.45] / 2] [sw * 2]
			apply-transform : Italify
		}
		include : smallo [CAP * 0.45 + sw * 4] 0 SB RIGHTSB sw
		apply-transform : Upright
		apply-transform : Translate 0 [parenMid - [CAP * 0.45 + sw * 4] / 2]
		apply-transform : Italify
	}
}
define [createSuperscripts records] : if [not recursive] : begin {
	local pendingGlyphs : records.map : [record] -> record.1
	local miniatureFont : Miniature pendingGlyphs 3.7 0.7
	foreach (unicode glyphid) [items-of records] : create-glyph ['superscript_' + glyphid] : glyph-construction {
		if unicode : assign-unicode unicode
		include : create-glyph : glyph-construction {
			include miniatureFont.(glyphid)
			apply-transform : Upright
			apply-transform : Translate [-MIDDLE] [-CAP]
			apply-transform : Scale 0.7
			apply-transform : Translate MIDDLE CAP
			apply-transform : Italify
		}
	}
}
define [createSubscripts records] : if [not recursive] : begin {
	local pendingGlyphs : records.map : [record] -> record.1
	local miniatureFont : Miniature pendingGlyphs 3.7 0.7
	foreach (unicode glyphid) [items-of records] : create-glyph ['subscript_' + glyphid] : glyph-construction {
		if unicode : assign-unicode unicode
		include : create-glyph : glyph-construction {
			include miniatureFont.(glyphid)
			apply-transform : Upright
			apply-transform : Translate [-MIDDLE] 0
			apply-transform : Scale 0.7
			apply-transform : Translate MIDDLE [DESCENDER / 2]
			apply-transform : Italify
		}
	}
}

define [createFractions records] : if [not recursive] : begin {
	local pendingGlyphs : [records.map : [record] -> record.1].concat : records.map : [record] -> record.2
	local miniatureFont : Miniature pendingGlyphs 4 0.7
	foreach (unicode numid denid) [items-of records] : create-glyph ['fraction_' + numid + '_' + denid] : glyph-construction {
		if unicode : assign-unicode unicode
		local fine : adviceBlackness 3.7
		include : create-glyph : glyph-construction {
			include : create-glyph : glyph-construction {
				include miniatureFont.(numid)
				apply-transform : Translate [MIDDLE - miniatureFont.(numid).advanceWidth / 2] 0
			}
			apply-transform : Upright
			apply-transform : Translate 0 [CAP + fine * 4]
			apply-transform : Italify
			include : create-glyph : glyph-construction {
				include miniatureFont.(denid)
				apply-transform : Translate [MIDDLE - miniatureFont.(denid).advanceWidth / 2] 0
			}
			apply-transform : Upright
			apply-transform : Translate [-MIDDLE] [-CAP - fine * 2]
			apply-transform : Scale 0.5
			apply-transform : Translate MIDDLE parenMid
			apply-transform : Italify
		}
		include : HBar SB RIGHTSB parenMid [fine * 0.75]
	}
}

createCircledGlyphs : list {
	list 0xA9   'C'
	list 0xAE   'R'
	list 0x2117 'P'
}

create-glyph 'ordfeminine' : glyph-construction {
	assign-unicode 0xAA
	include [Miniature ('a') 3.7 0.7].a
	include : create-stroke
		:.start-from SB DESCENDER
		:.set-width  STROKE 0
		:.heads-to   RIGHTWARD
		:.line-to    RIGHTSB DESCENDER
		:.heads-to   RIGHTWARD
	
	apply-transform : Upright
	apply-transform : Translate [-MIDDLE] [-XH]
	apply-transform : Scale 0.7
	apply-transform : Translate MIDDLE CAP
	apply-transform : Italify
}
create-glyph 'ordmasculine' : glyph-construction {
	assign-unicode 0xBA
	include [Miniature ('o') 3.7 0.7].o
	include : create-stroke
		:.start-from SB DESCENDER
		:.set-width  STROKE 0
		:.heads-to   RIGHTWARD
		:.line-to    RIGHTSB DESCENDER
		:.heads-to   RIGHTWARD
	
	apply-transform : Upright
	apply-transform : Translate [-MIDDLE] [-XH]
	apply-transform : Scale 0.7
	apply-transform : Translate MIDDLE CAP
	apply-transform : Italify
}

createSuperscripts : list {
	list 0x2070 'zero'
	list 0x00B9 'one'
	list 0x00B2 'two'
	list 0x00B3 'three'
	list 0x2074 'four'
	list 0x2075 'five'
	list 0x2076 'six'
	list 0x2077 'seven'
	list 0x2078 'eight'
	list 0x2079 'nine'
	list 0x02B0 'h'
	list 0x02B2 'j'
	list 0x02B3 'r'
	list 0x02B7 'w'
	list 0x02B8 'y'
	list 0x02E1 'l'
	list 0x02E2 's'
	list 0x02E3 'x'
	list 0x2071 'i'
	list 0x207F 'n'
	list 0x1D43 'a'
	list 0x1D47 'b'
	list 0x1D48 'd'
	list 0x1D49 'e'
	list 0x1D4D 'g'
	list 0x1D4F 'k'
	list 0x1D50 'm'
	list 0x1D52 'o'
	list 0x1D56 'p'
	list 0x1D57 't'
	list 0x1D58 'u'
	list 0x1D5B 'v'
	list 0x1D9C 'c'
	list 0x1DA0 'f'
	list 0x1DBB 'z'
	list 0x1D2C 'A'
	list 0x1D2E 'B'
	list 0x1D30 'D'
	list 0x1D31 'E'
	list 0x1D33 'G'
	list 0x1D34 'H'
	list 0x1D35 'I'
	list 0x1D36 'J'
	list 0x1D37 'K'
	list 0x1D38 'L'
	list 0x1D39 'M'
	list 0x1D3A 'N'
	list 0x1D3C 'O'
	list 0x1D3E 'P'
	list 0x1D3F 'R'
	list null   'S' # there is no superscript S in unicode, but is is used for the SM symbol
	list 0x1D40 'T'
	list 0x1D41 'U'
	list 0x1D42 'W'
}

createSubscripts : list {
	list 0x2080 'zero'
	list 0x2081 'one'
	list 0x2082 'two'
	list 0x2083 'three'
	list 0x2084 'four'
	list 0x2085 'five'
	list 0x2086 'six'
	list 0x2087 'seven'
	list 0x2088 'eight'
	list 0x2089 'nine'
	list 0x2090 'a'
	list 0x2091 'e'
	list 0x2092 'o'
	list 0x2093 'x'
	# list 0x2094 'reve'
	list 0x2095 'h'
	list 0x2096 'k'
	list 0x2097 'l'
	list 0x2098 'm'
	list 0x2099 'n'
	list 0x209A 'p'
	list 0x209B 's'
	list 0x209C 't'
	list 0x1D62 'i'
	list 0x1D63 'r'
	list 0x1D64 'u'
	list 0x1D65 'v'
}

createFractions : list {
	# Unicode fractions
	list 0x00BC 'one' 'four'
	list 0x00BD 'one' 'two'
	list 0x00BE 'three' 'four'
	list 0x2150 'one' 'seven'
	list 0x2151 'one' 'nine'
	list 0x2152 'one' 'ten'
	list 0x2153 'one' 'three'
	list 0x2154 'two' 'three'
	list 0x2155 'one' 'five'
	list 0x2156 'two' 'five'
	list 0x2157 'three' 'five'
	list 0x2158 'four' 'five'
	list 0x2159 'one' 'six'
	list 0x215A 'five' 'six'
	list 0x215B 'one' 'eight'
	list 0x215C 'three' 'eight'
	list 0x215D 'five' 'eight'
	list 0x215E 'seven' 'eight'
	list 0x2189 'zero' 'three'
	
	# Powerline LN symbol
	list 0xE0A1 'L' 'N'
}

# Composite superscripts and subscripts
define [doubleSuperscript a b] : glyph-construction {
	include a
	apply-transform : Translate [-WIDTH * 0.6] 0
	include b
	apply-transform : Upright
	apply-transform : Translate [-WIDTH * 0.2] [-CAP]
	apply-transform : Scale 0.8
	apply-transform : Translate MIDDLE CAP
	apply-transform : Italify
}
create-glyph 'trademark' : glyph-construction {
	assign-unicode 0x2122
	include : doubleSuperscript glyphs.superscript_T glyphs.superscript_M
}
create-glyph 'servicemark' : glyph-construction {
	assign-unicode 0x2120
	include : doubleSuperscript glyphs.superscript_S glyphs.superscript_M
}

# Build accented glyphs

define [isAboveMark mark] : mark && mark.anchors && mark.anchors.above && mark.anchors.above.type === MARK

define customDecompositions (
	# Latvians use comma instead of cedillas in several letters.
	# Record them as custom decomposition.
	."\u0156" "R\u0326"
	."\u0157" "r\u0326"
	."\u0136" "K\u0326"
	."\u0137" "k\u0326"
	."\u0145" "N\u0326"
	."\u0146" "n\u0326"
	."\u013B" "L\u0326"
	."\u013C" "l\u0326"
	."\u0122" "G\u0326"
	."\u0123" "g\u0312"
	
	# Cyrillic composite characters
	."\u0498" "\u0417\u0327"
	."\u0499" "\u0437\u0327"
	."\u04AA" "\u0421\u0327"
	."\u04AB" "\u0441\u0327"
	
	# Spacing modifers
	."`"      " \u0300"
	."\u02CB" " \u0300"
	."\u00B4" " \u0301"
	."\u02CA" " \u0301"
	."^"      " \u0302"
	."\u02C6" " \u0302"
	."~"      " \u0303"
	."\u02DC" " \u0303"
	."\u00AF" " \u0304"
	."\u02C9" " \u0304"
	."\u02D8" " \u0306"
	."\u02D9" " \u0307"
	."\u00A8" " \u0308"
	."\u00B0" " \u030A"
	."\u02DA" " \u030A"
	."\u02C7" " \u030C"
	."\u00B8" " \u0327"

	."\u1FED" " \u0308\u0300"
	."\u1FEE" " \u0308\u0301"
	."\u1FEF" " \u0300"
	."\u1FFD" " \u0301"
	."\u1FFE" " \u0314"
	."\u1FBD" " \u0313"
	."\u1FBE" " \u0345"
	."\u1FBF" " \u0313"
	."\u1FC0" " \u0342"
	."\u1FC1" " \u0308\u0342"
	."\u0384" " \u0301"
	."\u0385" " \u0308\u0301"
)
define [decompositionModify s] : s.replace [regex '\u0313\u0300'] "\u1FCD"
	:.replace [regex '\u0313\u0301'] "\u1FCE"
	:.replace [regex '\u0313\u0342'] "\u1FCF"
	:.replace [regex '\u0314\u0300'] "\u1FDD"
	:.replace [regex '\u0314\u0301'] "\u1FDE"
	:.replace [regex '\u0314\u0342'] "\u1FDF"

foreach code [range 0x0000 0xFFFF] : if [not unicodeGlyphs`code] : begin {
	local str : String.fromCharCode code
	local nfd : fallback customDecompositions.(str) : decompositionModify : str.normalize 'NFD'
	if [nfd.length > 1] : begin {
		local parts ()
		local allFound true
		local hasMarkAbove false
		foreach j [range 0 nfd.length] : begin {
			set parts`j unicodeGlyphs`[nfd.charCodeAt j]
			if [not parts`j] : set allFound false
			if [isAboveMark parts`j] : set hasMarkAbove true
		}
		if allFound : begin {
			local namingParts : parts.slice 0
			if [[parts.0 === glyphs.i || parts.0 === glyphs.ukrainiani] && hasMarkAbove] : parts.0 = glyphs.dotlessi
			if [parts.0 === glyphs.j && hasMarkAbove] : parts.0 = glyphs.dotlessj
			local glyphName : namingParts.map [[part] -> part.name] :.join '_'
			if glyphs.(glyphName) : begin {
				local j 2
				while glyphs.[glyphName + '.alias' + j] : inc j
				set glyphName [glyphName + '.alias' + j]
			}
			create-glyph glyphName : glyph-construction {
				assign-unicode code
				include parts.0 AS_BASE
				foreach part [items-of : parts.slice 1] : include part
			}
		}
	}
}