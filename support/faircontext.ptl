import './transform' as : Transform && [object [transformPoint tp] [untransform utp] inverse]
import './point' as Point

define [fallback] : for [local j 0] (j < arguments.length) [inc j] : if (arguments.(j) !== nothing) : return arguments.(j)
define [linreg x0 y0 x1 y1 x] : y0 + (x - x0) * (y1 - y0) / (x1 - x0)

define-macro xytransform : syntax-rules
	`[xytransform @tfm @x @y] : let [t : env.newt] `[begin \\
		set @t @x
		set @x : @x * @tfm.xx + @y * @tfm.yx + @tfm.x
		set @y : @t * @tfm.xy + @y * @tfm.yy + @tfm.y
	]

define SEGMENTS 5
export all : define [FairConversionContext] : begin
	set this.gizmo [Transform.Id]
	set this.contour {}
	set this.pendings {}
	return nothing

define [fair start points] : return points

define [FairConversionContext.prototype.moveTo x y] : begin
	xytransform this.gizmo x y
	this.contour.push : new Point x y true

define [FairConversionContext.prototype.lineTo x y] : begin
	xytransform this.gizmo x y
	if this.pendings.length
	: then
		local last : this.contour.(this.contour.length - 1)
		this.pendings.push : new Point x y true
		set this.contour : this.contour.concat : fair last this.pendings
		set this.pendings {}
	: else : this.contour.push : new Point x y true

define [FairConversionContext.prototype.cubicTo x1 y1 x2 y2 x y unimportant] : begin
	xytransform this.gizmo x1 y1
	xytransform this.gizmo x2 y2
	xytransform this.gizmo x y
	piecewise
		(!unimportant && this.pendings.length) : begin
			local last : this.contour.(this.contour.length - 1)
			this.pendings.push : new Point x y true
			set this.contour : this.contour.concat : fair last this.pendings
			set this.pendings {}
		(!unimportant) : begin
			this.contour.push : new Point x1 y1 false true
			this.contour.push : new Point x2 y2 false true
			this.contour.push : new Point x  y  true
		true : begin
			this.pendings.push : new Point x1 y1 false true
			this.pendings.push : new Point x2 y2 false true
			this.pendings.push : new Point x  y  true